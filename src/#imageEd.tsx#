"use client"

import type React from "react"
import { useRef, useState, useCallback } from "react"

type CropState = 'inactive' | 'creating' | 'set' | 'moving' | 'resizing'
type ResizeHandle = 'nw' | 'ne' | 'sw' | 'se' | null
 
export default function HomePage() {
  const fileInputRef = useRef<HTMLInputElement>(null)
  const canvasRef = useRef<HTMLCanvasElement>(null)
  const [currentTool, setCurrentTool] = useState("pencil")
  const [currentColor, setCurrentColor] = useState("#000000")
  const [brushSize, setBrushSize] = useState(5)
  const [imageData, setImageData] = useState<ImageData | null>(null)
  const [cropMode, setCropMode] = useState(false)
  const [cropStart, setCropStart] = useState<{ x: number; y: number } | null>(null)
  const [cropEnd, setCropEnd] = useState<{ x: number; y: number } | null>(null)
  const [cropState, setCropState] = useState<CropState>('inactive')
  const [isDrawing, setIsDrawing] = useState(false)
  const [cropGuide, setCropGuide] = useState<string | null>(null)
  const [dragOffset, setDragOffset] = useState<{ x: number; y: number } | null>(null)
  const [activeHandle, setActiveHandle] = useState<ResizeHandle>(null)
  const [cursorStyle, setCursorStyle] = useState('default')
  const [lastTouchTime, setLastTouchTime] = useState<{ [key: string]: number }>({})

  const saveImageData = useCallback(() => {
    const canvas = canvasRef.current
    if (canvas) {
      const ctx = canvas.getContext("2d")
      if (ctx) {
        setImageData(ctx.getImageData(0, 0, canvas.width, canvas.height))
      }
    }
  }, [])

  const restoreImageData = useCallback(() => {
    const canvas = canvasRef.current
    if (canvas && imageData) {
      const ctx = canvas.getContext("2d")
      if (ctx) {
        canvas.width = imageData.width
        canvas.height = imageData.height
        ctx.putImageData(imageData, 0, 0)
      }
    }
  }, [imageData])

  const flipAspectRatio = useCallback((ratio: string) => {
    if (ratio === "1:1") return "1:1"
    const [w, h] = ratio.split(":").map(Number)
    return `${h}:${w}`
  }, [])

  const handleCropButtonClick = useCallback((ratio: string, isDoubleClick = false) => {
    const finalRatio = isDoubleClick ? flipAspectRatio(ratio) : ratio
    setCropMode(true)
    setCropGuide(finalRatio)
    setCropState('inactive')
    saveImageData()
  }, [flipAspectRatio, saveImageData])

  const handleCropButtonDoubleClick = useCallback((ratio: string) => {
    handleCropButtonClick(ratio, true)
  }, [handleCropButtonClick])

  const handleCropButtonTouchEnd = useCallback((ratio: string, e: React.TouchEvent) => {
    const now = Date.now()
    const lastTouch = lastTouchTime[ratio] || 0
    const timeDiff = now - lastTouch
    
    setLastTouchTime(prev => ({ ...prev, [ratio]: now }))
    
    if (timeDiff < 300) {
      e.preventDefault()
      handleCropButtonClick(ratio, true)
    } else {
      setTimeout(() => {
        const currentTime = lastTouchTime[ratio] || 0
        if (currentTime === now) {
          handleCropButtonClick(ratio, false)
        }
      }, 300)
    }
  }, [lastTouchTime, handleCropButtonClick])

  const cancelCrop = useCallback(() => {
    setCropMode(false)
    setCropStart(null)
    setCropEnd(null)
    setCropGuide(null)
    setCropState('inactive')
    setDragOffset(null)
    setActiveHandle(null)
    setCursorStyle('default')
    restoreImageData()
  }, [restoreImageData])

  const rotateImage = useCallback((degrees: number) => {
    const canvas = canvasRef.current
    if (!canvas) return

    const ctx = canvas.getContext("2d")
    if (!ctx) return

    const currentImageData = ctx.getImageData(0, 0, canvas.width, canvas.height)
    const tempCanvas = document.createElement("canvas")
    const tempCtx = tempCanvas.getContext("2d")
    if (!tempCtx) return

    if (degrees === 90 || degrees === 270) {
      tempCanvas.width = canvas.height
      tempCanvas.height = canvas.width
      canvas.width = tempCanvas.width
      canvas.height = tempCanvas.height
    } else {
      tempCanvas.width = canvas.width
      tempCanvas.height = canvas.height
    }

    tempCtx.translate(tempCanvas.width / 2, tempCanvas.height / 2)
    tempCtx.rotate((degrees * Math.PI) / 180)
    tempCtx.putImageData(currentImageData, -currentImageData.width / 2, -currentImageData.height / 2)

    ctx.clearRect(0, 0, canvas.width, canvas.height)
    ctx.drawImage(tempCanvas, 0, 0)
    saveImageData()
  }, [saveImageData])

  const flipImage = useCallback((direction: "horizontal" | "vertical") => {
    const canvas = canvasRef.current
    if (!canvas) return

    const ctx = canvas.getContext("2d")
    if (!ctx) return

    const currentImageData = ctx.getImageData(0, 0, canvas.width, canvas.height)
    ctx.clearRect(0, 0, canvas.width, canvas.height)
    ctx.save()

    if (direction === "horizontal") {
      ctx.scale(-1, 1)
      ctx.translate(-canvas.width, 0)
    } else {
      ctx.scale(1, -1)
      ctx.translate(0, -canvas.height)
    }

    ctx.putImageData(currentImageData, 0, 0)
    ctx.restore()
    saveImageData()
  }, [saveImageData])

  const resizeImage = useCallback((newWidth: number, newHeight: number) => {
    const canvas = canvasRef.current
    if (!canvas) return

    const ctx = canvas.getContext("2d")
    if (!ctx) return

    const currentImageData = ctx.getImageData(0, 0, canvas.width, canvas.height)
    const tempCanvas = document.createElement("canvas")
    const tempCtx = tempCanvas.getContext("2d")
    if (!tempCtx) return

    tempCanvas.width = canvas.width
    tempCanvas.height = canvas.height
    tempCtx.putImageData(currentImageData, 0, 0)

    canvas.width = newWidth
    canvas.height = newHeight
    ctx.clearRect(0, 0, newWidth, newHeight)
    ctx.drawImage(tempCanvas, 0, 0, newWidth, newHeight)
    saveImageData()
  }, [saveImageData])

  const boundCoordinates = useCallback((x: number, y: number, canvas: HTMLCanvasElement) => {
    return {
      x: Math.max(0, Math.min(x, canvas.width)),
      y: Math.max(0, Math.min(y, canvas.height))
    }
  }, [])

  const getCropRect = useCallback(() => {
    if (!cropStart || !cropEnd) return null
    
    const x = Math.min(cropStart.x, cropEnd.x)
    const y = Math.min(cropStart.y, cropEnd.y)
    const width = Math.abs(cropEnd.x - cropStart.x)
    const height = Math.abs(cropEnd.y - cropStart.y)
    
    return { x, y, width, height }
  }, [cropStart, cropEnd])

  const getResizeHandle = useCallback((mouseX: number, mouseY: number): ResizeHandle => {
    const rect = getCropRect()
    if (!rect) return null

    const tolerance = 6

    if (Math.abs(mouseX - rect.x) <= tolerance && Math.abs(mouseY - rect.y) <= tolerance) return 'nw'
    if (Math.abs(mouseX - (rect.x + rect.width)) <= tolerance && Math.abs(mouseY - rect.y) <= tolerance) return 'ne'
    if (Math.abs(mouseX - rect.x) <= tolerance && Math.abs(mouseY - (rect.y + rect.height)) <= tolerance) return 'sw'
    if (Math.abs(mouseX - (rect.x + rect.width)) <= tolerance && Math.abs(mouseY - (rect.y + rect.height)) <= tolerance) return 'se'

    return null
  }, [getCropRect])

  const isInsideCropArea = useCallback((mouseX: number, mouseY: number) => {
    const rect = getCropRect()
    if (!rect) return false

    return mouseX >= rect.x && mouseX <= rect.x + rect.width && 
           mouseY >= rect.y && mouseY <= rect.y + rect.height
  }, [getCropRect])

  const updateCursorStyle = useCallback((mouseX: number, mouseY: number) => {
    if (!cropMode || cropState === 'creating') {
      setCursorStyle('crosshair')
      return
    }

    const handle = getResizeHandle(mouseX, mouseY)
    if (handle) {
      const cursors = {
        'nw': 'nw-resize',
        'ne': 'ne-resize',
        'sw': 'sw-resize',
        'se': 'se-resize'
      }
      setCursorStyle(cursors[handle])
    } else if (isInsideCropArea(mouseX, mouseY)) {
      setCursorStyle('move')
    } else {
      setCursorStyle('crosshair')
    }
  }, [cropMode, cropState, getResizeHandle, isInsideCropArea])

  const drawCropOverlay = useCallback(() => {
    const canvas = canvasRef.current
    if (!canvas || !imageData || !cropStart || !cropEnd) return

    const ctx = canvas.getContext("2d")
    if (!ctx) return

    ctx.putImageData(imageData, 0, 0)

    const rect = getCropRect()
    if (!rect) return

    ctx.fillStyle = "rgba(0, 0, 0, 0.5)"
    ctx.fillRect(0, 0, canvas.width, rect.y)
    ctx.fillRect(0, rect.y + rect.height, canvas.width, canvas.height - rect.y - rect.height)
    ctx.fillRect(0, rect.y, rect.x, rect.height)
    ctx.fillRect(rect.x + rect.width, rect.y, canvas.width - rect.x - rect.width, rect.height)

    ctx.strokeStyle = "#00ff00"
    ctx.lineWidth = 2
    ctx.setLineDash([5, 5])
    ctx.strokeRect(rect.x, rect.y, rect.width, rect.height)
    ctx.setLineDash([])

    const handleSize = 12
    ctx.fillStyle = "#00ff00"
    ctx.strokeStyle = "#ffffff"
    ctx.lineWidth = 2

    const corners = [
      { x: rect.x, y: rect.y },
      { x: rect.x + rect.width, y: rect.y },
      { x: rect.x, y: rect.y + rect.height },
      { x: rect.x + rect.width, y: rect.y + rect.height }
    ]

    corners.forEach(corner => {
      ctx.fillRect(corner.x - handleSize/2, corner.y - handleSize/2, handleSize, handleSize)
      ctx.strokeRect(corner.x - handleSize/2, corner.y - handleSize/2, handleSize, handleSize)
    })

    ctx.fillStyle = "#00ff00"
    ctx.font = "12px Arial"
    ctx.textAlign = "center"
    ctx.fillText(`${Math.round(rect.width)} × ${Math.round(rect.height)}`, rect.x + rect.width/2, rect.y - 10)
  }, [cropStart, cropEnd, imageData, getCropRect])

  const getCanvasCoordinates = useCallback((e: React.MouseEvent<HTMLCanvasElement> | React.TouchEvent<HTMLCanvasElement>) => {
    const canvas = canvasRef.current
    if (!canvas) return { x: 0, y: 0 }

    const rect = canvas.getBoundingClientRect()
    
    let clientX: number, clientY: number
    
    if ('touches' in e && e.touches.length > 0) {
      clientX = e.touches[0].clientX
      clientY = e.touches[0].clientY
    } else if ('clientX' in e) {
      clientX = e.clientX
      clientY = e.clientY
    } else {
      return { x: 0, y: 0 }
    }

    const x = (clientX - rect.left) * (canvas.width / rect.width)
    const y = (clientY - rect.top) * (canvas.height / rect.height)

    return boundCoordinates(x, y, canvas)
  }, [boundCoordinates])

  const handleStart = useCallback((e: React.MouseEvent<HTMLCanvasElement> | React.TouchEvent<HTMLCanvasElement>) => {
    const canvas = canvasRef.current
    if (!canvas) return

    const { x, y } = getCanvasCoordinates(e)

    if (cropMode) {
      if (!imageData) {
        saveImageData()
      }

      if (cropState === 'inactive' || cropState === 'creating') {
        setCropStart({ x, y })
        setCropEnd({ x, y })
        setCropState('creating')
      } else if (cropState === 'set') {
        const handle = getResizeHandle(x, y)
        if (handle) {
          setActiveHandle(handle)
          setCropState('resizing')
        } else if (isInsideCropArea(x, y)) {
          const rect = getCropRect()
          if (rect) {
            setDragOffset({ x: x - rect.x, y: y - rect.y })
            setCropState('moving')
          }
        } else {
          setCropStart({ x, y })
          setCropEnd({ x, y })
          setCropState('creating')
        }
      }
    } else {
      setIsDrawing(true)
    }

    e.preventDefault()
  }, [cropMode, cropState, imageData, saveImageData, getResizeHandle, isInsideCropArea, getCropRect, getCanvasCoordinates])

  const handleMove = useCallback((e: React.MouseEvent<HTMLCanvasElement> | React.TouchEvent<HTMLCanvasElement>) => {
    const canvas = canvasRef.current
    if (!canvas) return

    const { x, y } = getCanvasCoordinates(e)

    updateCursorStyle(x, y)

    if (!cropMode || !cropStart) return

    if (cropState === 'creating') {
      let endX = x
      let endY = y

      if (cropGuide) {
        const [ratioW, ratioH] = cropGuide.split(":").map(Number)
        const targetRatio = ratioW / ratioH

        const width = Math.abs(x - cropStart.x)
        const height = Math.abs(y - cropStart.y)

        if (width / height > targetRatio) {
          endY = cropStart.y + (y > cropStart.y ? width / targetRatio : -width / targetRatio)
        } else {
          endX = cropStart.x + (x > cropStart.x ? height * targetRatio : -height * targetRatio)
        }

        const bounded = boundCoordinates(endX, endY, canvas)
        endX = bounded.x
        endY = bounded.y
      }

      setCropEnd({ x: endX, y: endY })
    } else if (cropState === 'moving' && dragOffset && cropEnd) {
      const rect = getCropRect()
      if (!rect) return

      const newX = x - dragOffset.x
      const newY = y - dragOffset.y

      const boundedX = Math.max(0, Math.min(newX, canvas.width - rect.width))
      const boundedY = Math.max(0, Math.min(newY, canvas.height - rect.height))

      setCropStart({ x: boundedX, y: boundedY })
      setCropEnd({ x: boundedX + rect.width, y: boundedY + rect.height })
    } else if (cropState === 'resizing' && activeHandle && cropEnd) {
      const newCropEnd = { ...cropEnd }
      const newCropStart = { ...cropStart }

      if (activeHandle.includes('e')) newCropEnd.x = x
      if (activeHandle.includes('w')) newCropStart.x = x
      if (activeHandle.includes('s')) newCropEnd.y = y
      if (activeHandle.includes('n')) newCropStart.y = y

      setCropStart(newCropStart)
      setCropEnd(newCropEnd)
    }

    requestAnimationFrame(drawCropOverlay)
    e.preventDefault()
  }, [cropMode, cropStart, cropEnd, cropState, cropGuide, dragOffset, activeHandle, getCropRect, boundCoordinates, updateCursorStyle, drawCropOverlay, getCanvasCoordinates])

  const handleEnd = useCallback(() => {
    if (cropState === 'creating') {
      setCropState('set')
    } else if (cropState === 'moving') {
      setCropState('set')
      setDragOffset(null)
    } else if (cropState === 'resizing') {
      setCropState('set')
      setActiveHandle(null)
    }

    setIsDrawing(false)
  }, [cropState])

  const applyCrop = useCallback(() => {
    const canvas = canvasRef.current
    if (!canvas || !cropStart || !cropEnd) return

    const ctx = canvas.getContext("2d")
    if (!ctx) return

    const x = Math.min(cropStart.x, cropEnd.x)
    const y = Math.min(cropStart.y, cropEnd.y)
    const width = Math.abs(cropEnd.x - cropStart.x)
    const height = Math.abs(cropEnd.y - cropStart.y)

    if (width > 0 && height > 0) {
      const croppedImageData = ctx.getImageData(x, y, width, height)
      canvas.width = width
      canvas.height = height
      ctx.clearRect(0, 0, width, height)
      ctx.putImageData(croppedImageData, 0, 0)
      saveImageData()
    }

    setCropMode(false)
    setCropStart(null)
    setCropEnd(null)
    setCropGuide(null)
    setCropState('inactive')
  }, [cropStart, cropEnd, saveImageData])

  const handleFileUpload = (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0]
    if (file && file.type.startsWith("image/")) {
      const reader = new FileReader()
      reader.onload = (e) => {
        const img = new Image()
        img.onload = () => {
          const canvas = canvasRef.current
          if (canvas) {
            const ctx = canvas.getContext("2d")
            if (ctx) {
              const maxWidth = Math.min(window.innerWidth - 50, 1800)
              const maxHeight = Math.min(window.innerHeight - 200, 1200)

              let canvasWidth = img.width
              let canvasHeight = img.height

              if (canvasWidth > maxWidth || canvasHeight > maxHeight) {
                const scaleX = maxWidth / canvasWidth
                const scaleY = maxHeight / canvasHeight
                const scale = Math.min(scaleX, scaleY)

                canvasWidth = Math.floor(canvasWidth * scale)
                canvasHeight = Math.floor(canvasHeight * scale)
              }

              canvas.width = canvasWidth
              canvas.height = canvasHeight
              ctx.clearRect(0, 0, canvasWidth, canvasHeight)
              ctx.drawImage(img, 0, 0, canvasWidth, canvasHeight)
              saveImageData()
            }
          }
        }
        img.src = e.target?.result as string
      }
      reader.readAsDataURL(file)
    }
  }

  const triggerFileUpload = () => {
    fileInputRef.current?.click()
  }

  const clearCanvas = () => {
    const canvas = canvasRef.current
    if (canvas) {
      const ctx = canvas.getContext("2d")
      if (ctx) {
        ctx.clearRect(0, 0, canvas.width, canvas.height)
        setImageData(null)
      }
    }
  }

  const exportImage = () => {
    const canvas = canvasRef.current
    if (canvas) {
      const link = document.createElement("a")
      link.download = "edited-image.png"
      link.href = canvas.toDataURL()
      link.click()
    }
  }

  // Styles
  const cardStyle: React.CSSProperties = {
    backgroundColor: 'white',
    border: '1px solid #e0e0e0',
    borderRadius: '12px',
    boxShadow: '0 4px 12px rgba(0,0,0,0.1)',
    overflow: 'hidden'
  }

  const cardHeaderStyle: React.CSSProperties = {
    padding: '20px',
    borderBottom: '1px solid #e0e0e0',
    backgroundColor: '#f8f9fa'
  }

  const cardContentStyle: React.CSSProperties = {
    padding: '20px'
  }

  const buttonStyle: React.CSSProperties = {
    padding: '12px 16px',
    border: 'none',
    borderRadius: '8px',
    fontSize: '14px',
    fontWeight: '500',
    cursor: 'pointer',
    transition: 'all 0.2s ease',
    display: 'inline-flex',
    alignItems: 'center',
    justifyContent: 'center',
    gap: '8px'
  }

  const primaryButtonStyle: React.CSSProperties = {
    ...buttonStyle,
    backgroundColor: '#007bff',
    color: 'white'
  }

  const outlineButtonStyle: React.CSSProperties = {
    ...buttonStyle,
    backgroundColor: 'white',
    color: '#333',
    border: '1px solid #ddd'
  }

  const secondaryButtonStyle: React.CSSProperties = {
    ...buttonStyle,
    backgroundColor: '#6c757d',
    color: 'white'
  }

  const destructiveButtonStyle: React.CSSProperties = {
    ...buttonStyle,
    backgroundColor: '#dc3545',
    color: 'white'
  }

  return (
    <div style={{ minHeight: '100vh', backgroundColor: '#f5f7fa', padding: '20px' }}>
      <input 
        ref={fileInputRef} 
        type="file" 
        accept="image/*" 
        onChange={handleFileUpload} 
        style={{ display: "none" }} 
      />

      <div style={{ maxWidth: '1400px', margin: '0 auto' }}>
        <header style={{ textAlign: 'center', marginBottom: '40px' }}>
          <h1 style={{ fontSize: '48px', fontWeight: 'bold', color: '#2c3e50', margin: '0 0 16px 0' }}>
            🎨 Image Editor Pro
          </h1>
          <p style={{ fontSize: '18px', color: '#6c757d', margin: 0 }}>
            Professional Image Editing with HTML5 Canvas
          </p>
        </header>

        <div style={{ 
          display: 'grid', 
          gridTemplateColumns: 'repeat(auto-fit, minmax(320px, 1fr))', 
          gap: '24px', 
          marginBottom: '40px' 
        }}>
          {/* Transform Tools */}
          <div style={cardStyle}>
            <div style={cardHeaderStyle}>
              <h3 style={{ margin: '0 0 8px 0', fontSize: '18px', fontWeight: '600', color: '#2c3e50' }}>
                🔄 Transform
              </h3>
              <p style={{ margin: 0, fontSize: '14px', color: '#6c757d' }}>
                Rotate, flip, and resize your image
              </p>
            </div>
            <div style={cardContentStyle}>
              <div style={{ display: 'flex', flexDirection: 'column', gap: '12px' }}>
                <button 
                  style={outlineButtonStyle}
                  onClick={() => rotateImage(90)}
                >
                  ↻ Rotate 90°
                </button>
                <button 
                  style={outlineButtonStyle}
                  onClick={() => rotateImage(180)}
                >
                  ⟲ Rotate 180°
                </button>
                <button 
                  style={outlineButtonStyle}
                  onClick={() => flipImage("horizontal")}
                >
                  ↔ Flip Horizontal
                </button>
                <button 
                  style={outlineButtonStyle}
                  onClick={() => flipImage("vertical")}
                >
                  ↕ Flip Vertical
                </button>
              </div>
            </div>
          </div>

          {/* Crop Tools */}
          <div style={cardStyle}>
            <div style={cardHeaderStyle}>
              <h3 style={{ margin: '0 0 8px 0', fontSize: '18px', fontWeight: '600', color: '#2c3e50' }}>
                ✂️ Crop & Guides
              </h3>
              <p style={{ margin: 0, fontSize: '14px', color: '#6c757d' }}>
                Crop with aspect ratio guides
              </p>
            </div>
            <div style={cardContentStyle}>
              <div style={{ display: 'flex', flexDirection: 'column', gap: '12px' }}>
                <button
                  style={cropMode ? primaryButtonStyle : outlineButtonStyle}
                  onClick={() => {
                    if (!cropMode) {
                      setCropMode(true)
                      setCropState('inactive')
                      saveImageData()
                    } else {
                      cancelCrop()
                    }
                    setCropGuide(null)
                  }}
                >
                  ✂️ {cropMode ? "Cancel Crop" : "Free Crop"}
                </button>

                {cropMode && cropState === 'set' && (
                  <button 
                    style={secondaryButtonStyle} 
                    onClick={applyCrop}
                  >
                    ✓ Apply Crop
                  </button>
                )}

                <div style={{ display: 'grid', gridTemplateColumns: 'repeat(2, 1fr)', gap: '8px' }}>
                  {[
                    { ratio: "1:1", label: "1:1" },
                    { ratio: "4:3", label: cropGuide === "3:4" ? "3:4" : "4:3" },
                    { ratio: "16:9", label: cropGuide === "9:16" ? "9:16" : "16:9" },
                    { ratio: "9:21", label: cropGuide === "21:9" ? "21:9" : "9:21" },
                    { ratio: "2:3", label: cropGuide === "3:2" ? "3:2" : "2:3" },
                    { ratio: "4:5", label: cropGuide === "5:4" ? "5:4" : "4:5" }
                  ].map(({ ratio, label }) => (
                    <button
                      key={ratio}
                      style={{
                        ...buttonStyle,
                        fontSize: '12px',
                        padding: '8px 12px',
                        backgroundColor: cropGuide?.includes(ratio.split(':')[0]) && cropGuide?.includes(ratio.split(':')[1]) 
                          ? '#007bff' : 'white',
                        color: cropGuide?.includes(ratio.split(':')[0]) && cropGuide?.includes(ratio.split(':')[1]) 
                          ? 'white' : '#333',
                        border: '1px solid #ddd'
                      }}
                      onClick={() => handleCropButtonClick(ratio)}
                      onDoubleClick={() => handleCropButtonDoubleClick(ratio)}
                      onTouchEnd={(e) => handleCropButtonTouchEnd(ratio, e)}
                    >
                      {label}
                    </button>
                  ))}
                </div>
              </div>
            </div>
          </div>

          {/* Drawing Tools */}
          <div style={cardStyle}>
            <div style={cardHeaderStyle}>
              <h3 style={{ margin: '0 0 8px 0', fontSize: '18px', fontWeight: '600', color: '#2c3e50' }}>
                ✏️ Drawing Tools
              </h3>
              <p style={{ margin: 0, fontSize: '14px', color: '#6c757d' }}>
                Draw and edit on your image
              </p>
            </div>
            <div style={cardContentStyle}>
              <div style={{ display: 'flex', flexDirection: 'column', gap: '12px' }}>
                <button
                  style={currentTool === "pencil" ? primaryButtonStyle : outlineButtonStyle}
                  onClick={() => setCurrentTool("pencil")}
                >
                  ✏️ Pencil
                </button>
                <button
                  style={currentTool === "eraser" ? primaryButtonStyle : outlineButtonStyle}
                  onClick={() => setCurrentTool("eraser")}
                >
                  🗑️ Eraser
                </button>
                <div style={{ display: 'flex', alignItems: 'center', gap: '12px' }}>
                  <input
                    type="color"
                    value={currentColor}
                    onChange={(e) => setCurrentColor(e.target.value)}
                    style={{ 
                      width: '40px', 
                      height: '40px', 
                      border: '1px solid #ddd', 
                      borderRadius: '6px',
                      cursor: 'pointer'
                    }}
                  />
                  <input
                    type="range"
                    min="1"
                    max="50"
                    value={brushSize}
                    onChange={(e) => setBrushSize(Number(e.target.value))}
                    style={{ flex: 1 }}
                  />
                  <span style={{ fontSize: '12px', color: '#666', minWidth: '35px' }}>
                    {brushSize}px
                  </span>
                </div>
              </div>
            </div>
          </div>

          {/* File Operations */}
          <div style={cardStyle}>
            <div style={cardHeaderStyle}>
              <h3 style={{ margin: '0 0 8px 0', fontSize: '18px', fontWeight: '600', color: '#2c3e50' }}>
                📁 File Operations
              </h3>
              <p style={{ margin: 0, fontSize: '14px', color: '#6c757d' }}>
                Load, save, and export images
              </p>
            </div>
            <div style={cardContentStyle}>
              <div style={{ display: 'flex', flexDirection: 'column', gap: '12px' }}>
                <button 
                  style={secondaryButtonStyle} 
                  onClick={triggerFileUpload}
                >
                  📂 Open Image
                </button>
                <button 
                  style={secondaryButtonStyle} 
                  onClick={exportImage}
                >
                  💾 Export PNG
                </button>
                <button 
                  style={destructiveButtonStyle} 
                  onClick={clearCanvas}
                >
                  🗑️ Clear Canvas
                </button>
                <div style={{ display: 'flex', gap: '8px' }}>
                  <button 
                    style={{
                      ...outlineButtonStyle,
                      flex: 1,
                      fontSize: '12px',
                      padding: '8px 12px'
                    }}
                    onClick={() => resizeImage(800, 600)}
                  >
                    800×600
                  </button>
                  <button 
                    style={{
                      ...outlineButtonStyle,
                      flex: 1,
                      fontSize: '12px',
                      padding: '8px 12px'
                    }}
                    onClick={() => resizeImage(1920, 1080)}
                  >
                    1920×1080
                  </button>
                </div>
              </div>
            </div>
          </div>
        </div>

        {/* Canvas Area */}
        <div style={cardStyle}>
          <div style={cardHeaderStyle}>
            <h3 style={{ margin: '0 0 16px 0', fontSize: '18px', fontWeight: '600', color: '#2c3e50' }}>
              🎨 Image Editor Canvas
            </h3>
            {cropMode && (
              <div style={{ 
                padding: '16px',
                backgroundColor: '#fff3cd',
                border: '1px solid #ffeaa7',
                borderRadius: '8px',
                fontSize: '14px',
                color: '#856404'
              }}>
                <div style={{ marginBottom: '8px' }}>
                  <strong>
                    {cropGuide
                      ? `Crop Mode: ${cropGuide} ratio`
                      : "Crop Mode: Free form"}
                  </strong>
                </div>
                <div style={{ fontSize: '12px', opacity: 0.8 }}>
                  Drag to create • Click inside to move • Drag corners to resize
                  <br />
                  Double-click ratio buttons to flip orientation • State: {cropState}
                </div>
              </div>
            )}
          </div>
          <div style={cardContentStyle}>
            <div style={{ 
              border: '2px dashed #ddd',
              borderRadius: '12px',
              padding: '16px',
              textAlign: 'center',
              backgroundColor: '#fafbfc',
              overflow: 'auto'
            }}>
              <canvas
                ref={canvasRef}
                width="800"
                height="400"
                style={{
                  maxWidth: '100%',
                  maxHeight: '80vh',
                  height: 'auto',
                  objectFit: 'contain',
                  cursor: cursorStyle,
                  border: '1px solid #e0e0e0',
                  borderRadius: '8px',
                  boxShadow: '0 2px 8px rgba(0,0,0,0.1)',
                  backgroundColor: 'white',
                  display: 'block',
                  margin: '0 auto'
                }}
                onMouseDown={handleStart}
                onMouseMove={handleMove}
                onMouseUp={handleEnd}
                onTouchStart={handleStart}
                onTouchMove={handleMove}
                onTouchEnd={handleEnd}
              >
                Your browser does not support the HTML5 canvas element.
              </canvas>
            </div>
          </div>
        </div>

        {/* Status Bar */}
        <div style={{
          marginTop: '24px',
          padding: '16px 24px',
          backgroundColor: 'white',
          border: '1px solid #e0e0e0',
          borderRadius: '12px',
          boxShadow: '0 2px 8px rgba(0,0,0,0.05)'
        }}>
          <div style={{
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'space-between',
            fontSize: '14px',
            color: '#6c757d'
          }}>
            <div style={{ display: 'flex', alignItems: 'center', gap: '24px', flexWrap: 'wrap' }}>
              <span>
                <strong>Mode:</strong>{" "}
                {cropMode
                  ? cropGuide
                    ? `Crop ${cropGuide} (${cropState})`
                    : `Free Crop (${cropState})`
                  : currentTool.charAt(0).toUpperCase() + currentTool.slice(1)}
              </span>
              <span>
                <strong>Color:</strong> {currentColor}
              </span>
              <span>
                <strong>Size:</strong> {canvasRef.current?.width || 800}×{canvasRef.current?.height || 400}
              </span>
            </div>
            <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
              <span style={{ 
                color: '#28a745',
                fontSize: '16px'
              }}>●</span>
              <span>Ready</span>
            </div>
          </div>
        </div>
      </div>
    </div>
  )
}
