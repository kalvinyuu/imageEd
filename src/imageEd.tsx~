"use client"

import { useRef, useState, useCallback, useEffect } from "react"
import { FontAwesomeIcon } from '@fortawesome/react-fontawesome'
import { 
  faUpload, faPaintBrush, faEraser, 
  faDownload, faRedo, faUndo, 
  faCrop, faExchangeAlt
} from '@fortawesome/free-solid-svg-icons'

type Tool = "brush" | "eraser" | "crop"
type Filter = "none" | "grayscale" | "sepia" | "vintage"

interface CropRect {
  x: number
  y: number
  width: number
  height: number
}


const cropPresets = [
  { name: "1:1", ratio: 1 },
  { name: "3:2", ratio: 3 / 2 },
  { name: "4:3", ratio: 4 / 3 },
  { name: "4:5", ratio: 4 / 5 },
  { name: "16:9", ratio: 16 / 9 },
  { name: "21:9", ratio: 21 / 9 },
  { name: "Custom", ratio: null, },
]

export default function ImageEditor() {
  // Refs
  const canvasRef = useRef<HTMLCanvasElement>(null)
  const fileInputRef = useRef<HTMLInputElement>(null)

  // Core State
  const [currentTool, setCurrentTool] = useState<Tool>("brush")
  const [brushSize, setBrushSize] = useState(5)
  const [brushColor, setBrushColor] = useState("#000000")
  const [isDrawing, setIsDrawing] = useState(false)
  const [originalImageData, setOriginalImageData] = useState<ImageData | null>(null)

  // Crop State (Simplified)
  const [cropRect, setCropRect] = useState<CropRect | null>(null)
  const [selectedPreset, setSelectedPreset] = useState("Custom")

  // History
  const [history, setHistory] = useState<ImageData[]>([])
  const [historyIndex, setHistoryIndex] = useState(-1)

  // Adjustments
  const [brightness, setBrightness] = useState(100)
  const [contrast, setContrast] = useState(100)
  const [currentFilter, setCurrentFilter] = useState<Filter>("none")

  // Save to history
  const saveToHistory = useCallback(() => {
    const canvas = canvasRef.current
    const ctx = canvas?.getContext("2d")
    if (!canvas || !ctx) return

    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height)
    const newHistory = history.slice(0, historyIndex + 1)
    newHistory.push(imageData)
    setHistory(newHistory)
    setHistoryIndex(newHistory.length - 1)
  }, [history, historyIndex])

  // Undo/Redo
  const undo = () => historyIndex > 0 && restoreHistoryState(historyIndex - 1)
  const redo = () => historyIndex < history.length - 1 && restoreHistoryState(historyIndex + 1)

  const restoreHistoryState = (index: number) => {
    const canvas = canvasRef.current
    const ctx = canvas?.getContext("2d")
    if (!canvas || !ctx) return

    ctx.putImageData(history[index], 0, 0)
    setHistoryIndex(index)
  }

  // Image Upload
  const handleFileUpload = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0]
    if (!file) return

    const reader = new FileReader()
    reader.onload = (e) => {
      const img = new Image()
      img.onload = () => {
        const canvas = canvasRef.current
        const ctx = canvas?.getContext("2d")
        if (!canvas || !ctx) return

        // Scale down large images
        const maxSize = 1200
        let { width, height } = img
        if (width > maxSize || height > maxSize) {
          const ratio = Math.min(maxSize / width, maxSize / height)
          width *= ratio
          height *= ratio
        }

        canvas.width = width
        canvas.height = height
        ctx.drawImage(img, 0, 0, width, height)

        const imageData = ctx.getImageData(0, 0, width, height)
        setOriginalImageData(imageData)
        setHistory([imageData])
        setHistoryIndex(0)
      }
      img.src = e.target?.result as string
    }
    reader.readAsDataURL(file)
  }

  // Drawing Logic
  const getCanvasCoordinates = (e: React.MouseEvent | React.TouchEvent) => {
    const canvas = canvasRef.current
    if (!canvas) return { x: 0, y: 0 }

    const rect = canvas.getBoundingClientRect()
    return {
      x: ((e as React.MouseEvent).clientX - rect.left) * (canvas.width / rect.width),
      y: ((e as React.MouseEvent).clientY - rect.top) * (canvas.height / rect.height)
    }
  }

  const startDrawing = (e: React.MouseEvent) => {
    if (currentTool === "crop") {
      const coords = getCanvasCoordinates(e)
      const size = Math.min(canvasRef.current?.width || 300, canvasRef.current?.height || 300) * 0.3
      const preset = cropPresets.find(p => p.name === selectedPreset)
      
      setCropRect({
        x: coords.x - size/2,
        y: coords.y - size/2,
        width: size,
        height: preset?.ratio ? size/preset.ratio : size
      })
      return
    }

    setIsDrawing(true)
    const canvas = canvasRef.current
    const ctx = canvas?.getContext("2d")
    if (!canvas || !ctx) return

    const coords = getCanvasCoordinates(e)
    ctx.beginPath()
    ctx.moveTo(coords.x, coords.y)
    ctx.lineWidth = brushSize
    ctx.lineCap = "round"
    ctx.strokeStyle = currentTool === "brush" ? brushColor : "rgba(0,0,0,1)"
    ctx.globalCompositeOperation = currentTool === "brush" ? "source-over" : "destination-out"
  }

  const draw = (e: React.MouseEvent) => {
    if (currentTool === "crop" && cropRect) {
      const coords = getCanvasCoordinates(e)
      setCropRect({
        ...cropRect,
        x: coords.x - cropRect.width/2,
        y: coords.y - cropRect.height/2
      })
      return
    }

    if (!isDrawing) return
    const canvas = canvasRef.current
    const ctx = canvas?.getContext("2d")
    if (!canvas || !ctx) return

    const coords = getCanvasCoordinates(e)
    ctx.lineTo(coords.x, coords.y)
    ctx.stroke()
  }

  const stopDrawing = () => {
    if (isDrawing) {
      setIsDrawing(false)
      saveToHistory()
    }
  }

  // Crop Functions
  const applyCrop = () => {
    const canvas = canvasRef.current
    const ctx = canvas?.getContext("2d")
    if (!canvas || !ctx || !cropRect) return

    const imageData = ctx.getImageData(
      Math.max(0, cropRect.x),
      Math.max(0, cropRect.y),
      Math.min(cropRect.width, canvas.width - cropRect.x),
      Math.min(cropRect.height, canvas.height - cropRect.y)
    )
    
    canvas.width = imageData.width
    canvas.height = imageData.height
    ctx.putImageData(imageData, 0, 0)
    
    setCropRect(null)
    saveToHistory()
  }

  const swapCropAxis = () => {
    if (!cropRect) return
    setCropRect({
      ...cropRect,
      width: cropRect.height,
      height: cropRect.width
    })
  }

  // Filters & Adjustments
  const applyFilter = (filter: Filter) => {
    const canvas = canvasRef.current
    const ctx = canvas?.getContext("2d")
    if (!canvas || !ctx || !originalImageData) return

    ctx.putImageData(originalImageData, 0, 0)
    if (filter === "none") {
      setCurrentFilter(filter)
      saveToHistory()
      return
    }

    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height)
    const data = imageData.data

    for (let i = 0; i < data.length; i += 4) {
      const r = data[i], g = data[i+1], b = data[i+2]
      
      if (filter === "grayscale") {
        const gray = r * 0.299 + g * 0.587 + b * 0.114
        data[i] = data[i+1] = data[i+2] = gray
      } 
      else if (filter === "sepia") {
        data[i] = Math.min(255, r * 0.393 + g * 0.769 + b * 0.189)
        data[i+1] = Math.min(255, r * 0.349 + g * 0.686 + b * 0.168)
        data[i+2] = Math.min(255, r * 0.272 + g * 0.534 + b * 0.131)
      }
      else if (filter === "vintage") {
        data[i] = Math.min(255, r * 1.2)
        data[i+1] = Math.min(255, g * 1.1)
        data[i+2] = Math.min(255, b * 0.8)
      }
    }

    ctx.putImageData(imageData, 0, 0)
    setCurrentFilter(filter)
    saveToHistory()
  }

  const applyAdjustments = useCallback(() => {
    const canvas = canvasRef.current
    const ctx = canvas?.getContext("2d")
    if (!canvas || !ctx || !originalImageData) return

    ctx.putImageData(originalImageData, 0, 0)
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height)
    const data = imageData.data

    const brightnessAdj = (brightness - 100) * 2.55
    const contrastAdj = contrast / 100

    for (let i = 0; i < data.length; i += 4) {
      // Brightness
      let r = data[i] + brightnessAdj
      let g = data[i+1] + brightnessAdj
      let b = data[i+2] + brightnessAdj

      // Contrast
      r = (r - 128) * contrastAdj + 128
      g = (g - 128) * contrastAdj + 128
      b = (b - 128) * contrastAdj + 128

      data[i] = Math.max(0, Math.min(255, r))
      data[i+1] = Math.max(0, Math.min(255, g))
      data[i+2] = Math.max(0, Math.min(255, b))
    }

    ctx.putImageData(imageData, 0, 0)
  }, [brightness, contrast, originalImageData])

  // Effects
  useEffect(() => {
    if (originalImageData) applyAdjustments()
  }, [brightness, contrast, applyAdjustments])

  // Render
  return (
    <div className="min-h-screen bg-gray-50 p-4">
      <div className="max-w-7xl mx-auto">
        <h1 className="text-3xl font-bold mb-4">Image Editor</h1>
        
        <div className="grid grid-cols-1 lg:grid-cols-4 gap-6">
          {/* Tools Panel */}
          <div className="lg:col-span-1 space-y-4">
            {/* Upload */}
            <div className="bg-white p-4 rounded-lg shadow">
              <h2 className="font-medium mb-2">Load Image</h2>
              <input ref={fileInputRef} type="file" accept="image/*" onChange={handleFileUpload} className="hidden" />
              <button 
                onClick={() => fileInputRef.current?.click()}
                className="w-full p-2 border rounded hover:bg-gray-100"
              >
                <FontAwesomeIcon icon={faUpload} className="mr-2" />
                Upload Image
              </button>
            </div>

            {/* Tools */}
            <div className="bg-white p-4 rounded-lg shadow">
              <h2 className="font-medium mb-2">Tools</h2>
              <div className="flex gap-2 mb-4">
                <button
                  onClick={() => setCurrentTool("brush")}
                  className={`p-2 rounded ${currentTool === "brush" ? 'bg-blue-500 text-white' : 'bg-gray-100'}`}
                >
                  <FontAwesomeIcon icon={faPaintBrush} />
                </button>
                <button
                  onClick={() => setCurrentTool("eraser")}
                  className={`p-2 rounded ${currentTool === "eraser" ? 'bg-blue-500 text-white' : 'bg-gray-100'}`}
                >
                  <FontAwesomeIcon icon={faEraser} />
                </button>
                <button
                  onClick={() => setCurrentTool("crop")}
                  className={`p-2 rounded ${currentTool === "crop" ? 'bg-blue-500 text-white' : 'bg-gray-100'}`}
                >
                  <FontAwesomeIcon icon={faCrop} />
                </button>
              </div>

              <div className="mb-4">
                <label className="block mb-1">Brush Size: {brushSize}px</label>
                <input 
                  type="range" 
                  min="1" 
                  max="50" 
                  value={brushSize} 
                  onChange={(e) => setBrushSize(parseInt(e.target.value))} 
                  className="w-full"
                />
              </div>

              <div>
                <label className="block mb-1">Color</label>
                <input 
                  type="color" 
                  value={brushColor} 
                  onChange={(e) => setBrushColor(e.target.value)} 
                  className="w-full h-10"
                />
              </div>
            </div>

            {/* Crop Tools */}
            {currentTool === "crop" && (
              <div className="bg-white p-4 rounded-lg shadow">
                <h2 className="font-medium mb-2">Crop</h2>
                <div className="grid grid-cols-2 gap-2 mb-4">
                  {cropPresets.map(preset => (
                    <button
                      key={preset.name}
                      onClick={() => setSelectedPreset(preset.name)}
                      className={`p-2 text-xs rounded ${
                        selectedPreset === preset.name 
                          ? 'bg-blue-500 text-white' 
                          : 'bg-gray-100 hover:bg-gray-200'
                      }`}
                    >
                      {preset.name}
                    </button>
                  ))}
                </div>
                {cropRect && (
                  <div className="space-y-2">
                    <button 
                      onClick={applyCrop}
                      className="w-full p-2 bg-blue-500 text-white rounded hover:bg-blue-600"
                    >
                      Apply Crop
                    </button>
                    <button 
                      onClick={() => setCropRect(null)}
                      className="w-full p-2 border rounded hover:bg-gray-100"
                    >
                      Cancel
                    </button>
                  </div>
                )}
              </div>
            )}

            {/* Adjustments */}
            <div className="bg-white p-4 rounded-lg shadow">
              <h2 className="font-medium mb-2">Adjustments</h2>
              <div className="space-y-4">
                <div>
                  <label className="block mb-1">Brightness: {brightness}%</label>
                  <input 
                    type="range" 
                    min="0" 
                    max="200" 
                    value={brightness} 
                    onChange={(e) => setBrightness(parseInt(e.target.value))} 
                    className="w-full"
                  />
                </div>
                <div>
                  <label className="block mb-1">Contrast: {contrast}%</label>
                  <input 
                    type="range" 
                    min="0" 
                    max="200" 
                    value={contrast} 
                    onChange={(e) => setContrast(parseInt(e.target.value))} 
                    className="w-full"
                  />
                </div>
              </div>
            </div>

            {/* Filters */}
            <div className="bg-white p-4 rounded-lg shadow">
              <h2 className="font-medium mb-2">Filters</h2>
              <div className="grid grid-cols-2 gap-2">
                {(["none", "grayscale", "sepia", "vintage"] as Filter[]).map(filter => (
                  <button
                    key={filter}
                    onClick={() => applyFilter(filter)}
                    className={`p-2 rounded capitalize ${
                      currentFilter === filter 
                        ? 'bg-blue-500 text-white' 
                        : 'bg-gray-100 hover:bg-gray-200'
                    }`}
                  >
                    {filter}
                  </button>
                ))}
              </div>
            </div>
          </div>

          {/* Canvas Area */}
          <div className="lg:col-span-3">
            <div className="bg-white rounded-lg shadow">
              <div className="p-4 border-b flex justify-between items-center">
                <h2 className="font-medium">Canvas</h2>
                <div className="flex gap-2">
                  <button 
                    onClick={undo}
                    disabled={historyIndex <= 0}
                    className="p-2 rounded border disabled:opacity-50 hover:bg-gray-100"
                  >
                    <FontAwesomeIcon icon={faUndo} />
                  </button>
                  <button 
                    onClick={redo}
                    disabled={historyIndex >= history.length - 1}
                    className="p-2 rounded border disabled:opacity-50 hover:bg-gray-100"
                  >
                    <FontAwesomeIcon icon={faRedo} />
                  </button>
                  <button 
                    onClick={() => canvasRef.current?.toBlob(blob => {
                      if (blob) window.open(URL.createObjectURL(blob))
                    })}
                    className="p-2 rounded border hover:bg-gray-100"
                  >
                    <FontAwesomeIcon icon={faDownload} />
                  </button>
                </div>
              </div>
              <div className="p-4">
                <div className="border-2 border-dashed border-gray-300 rounded-lg min-h-[500px] flex items-center justify-center bg-white">
                  <div className="relative">
                    <canvas
                      ref={canvasRef}
                      onMouseDown={startDrawing}
                      onMouseMove={draw}
                      onMouseUp={stopDrawing}
                      onMouseLeave={stopDrawing}
                      className="max-w-full max-h-[600px] border border-gray-200 rounded"
                      style={{
                        cursor: currentTool === "crop" ? "crosshair" : 
                                isDrawing ? "grabbing" : "default"
                      }}
                    />
                    {/* Crop Overlay */}
                    {currentTool === "crop" && cropRect && (
                      <div 
                        className="absolute border-2 border-white pointer-events-none"
                        style={{
                          left: `${cropRect.x}px`,
                          top: `${cropRect.y}px`,
                          width: `${cropRect.width}px`,
                          height: `${cropRect.height}px`,
                          boxShadow: "0 0 0 9999px rgba(0,0,0,0.5)"
                        }}
                      >
                        <button 
                          onClick={swapCropAxis}
                          className="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 p-1 bg-white rounded-full"
                        >
                          <FontAwesomeIcon icon={faExchangeAlt} className="text-gray-800" />
                        </button>
                      </div>
                    )}
                  </div>
                  {!canvasRef.current?.width && (
                    <div className="text-center text-gray-500 p-8">
                      <FontAwesomeIcon icon={faUpload} className="text-4xl mb-4" />
                      <p className="text-lg font-medium">Upload an image to start editing</p>
                    </div>
                  )}
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  )
}
